[metadata]
language = "Rust"
edition = "2021"
description = "Enhanced Rust development with modern tooling"

[tooling]
formatter = "cargo fmt"
linter = "cargo clippy"
test_framework = "cargo test"
package_manager = "cargo"
benchmark = "criterion"

[style]
case_functions = "snake_case"
case_types = "PascalCase"
case_constants = "SCREAMING_SNAKE_CASE"
naming = "descriptive, no abbreviations"

[commands]
format = "cargo fmt"
lint = "cargo clippy --all-targets --all-features -- -D warnings"
test = "cargo test"
check = "cargo check --all-targets --all-features"
build = "cargo build"
run = "cargo run"
bench = "cargo bench"

[dependencies]
core = [
    "anyhow = \"1.0\"",
    "serde = { version = \"1.0\", features = [\"derive\"] }",
    "tokio = { version = \"1.0\", features = [\"full\"] }",
    "tracing = \"0.1\"",
    "tracing-subscriber = \"0.3\"",
]
cli = [
    "clap = { version = \"4.0\", features = [\"derive\"] }",
]
dev = [
    "tempfile = \"3.8\"",
    "criterion = \"0.5\"",
]

[rules]
core = [
    "Use Rust 2021 edition exclusively with modern syntax and idioms",
    "Use latest stable Rust features and patterns",
    "Use modern control flow: if let chains, let-else patterns, match expressions",
    "Use async/await for I/O operations with tokio runtime",
]

style = [
    "Use cargo fmt for all code formatting (standard Rust formatting)",
    "Use cargo clippy with zero warnings policy for linting",
    "Use snake_case for variables and functions",
    "Use PascalCase for types and traits",
    "Use SCREAMING_SNAKE_CASE for constants",
    "Use descriptive variable names and avoid abbreviations",
]

error_handling = [
    "Use thiserror for library error types with structured error handling",
    "Use anyhow for application error handling and error propagation",
    "Use Result<T, E> for error handling, avoid unwrap() in production code",
    "Use proper error propagation with ? operator",
    "Use let-else patterns for early returns and error handling",
]

data_types = [
    "Use String for owned strings, &str for borrowed strings",
    "Use Vec<T> for dynamic collections instead of arrays",
    "Use HashMap and BTreeMap for key-value storage",
    "Use PathBuf for owned paths, &Path for borrowed paths",
    "Use generic types and traits for code reuse and flexibility",
    "Use #[derive(Debug, Clone, PartialEq)] for common traits",
]

structure = [
    "Use workspace structure for multi-crate projects",
    "Use modules for code organization and encapsulation",
    "Use pub(crate) for internal APIs that need cross-module access",
    "Use feature flags for optional functionality",
    "Use semantic versioning for crate releases",
]

libraries = [
    "Use serde for serialization with derive macros",
    "Use tracing for structured logging instead of println! in production code",
    "Use clap with derive API for command-line argument parsing",
    "Use tokio for async runtime and I/O operations",
    "Use criterion for benchmarking performance-critical code",
]

async = [
    "Use async/await patterns for I/O operations with tokio runtime",
    "Use async traits for async behavior",
    "Use proper async error handling patterns",
    "Use structured concurrency patterns",
]

testing = [
    "Use #[cfg(test)] modules for unit tests",
    "Use assert! and assert_eq! for test assertions",
    "Use integration tests in tests/ directory",
    "Use property-based testing with proptest for complex logic",
    "Use mock objects and test doubles for external dependencies",
]

workflow = [
    "Run cargo fmt before committing code",
    "Run cargo clippy --all-targets --all-features -- -D warnings before committing",
    "Run cargo test to verify all tests pass",
    "Run cargo check --all-targets --all-features for compilation verification",
    "Maintain zero linting warnings and compilation errors",
]

documentation = [
    "Use documentation comments /// for public APIs",
    "Write comprehensive examples in doc comments",
    "Use type aliases for complex types to improve readability",
    "Document error conditions and panic scenarios",
]

performance = [
    "Use iterators and functional programming patterns where appropriate",
    "Use lifetime annotations only when necessary, prefer owned types",
    "Avoid unsafe code unless absolutely necessary",
    "Use smart pointers (Arc, Rc) for shared ownership",
    "Use proper memory management patterns",
]

memory = [
    "Use Box<T> for heap allocation when needed",
    "Use Cow<T> for clone-on-write semantics",
    "Use proper lifetime management",
    "Avoid memory leaks and dangling pointers",
    "Use RAII patterns for resource management",
]

concurrency = [
    "Use channels for message passing between threads",
    "Use mutexes and RwLocks for shared state",
    "Use atomic types for lock-free programming",
    "Use rayon for data parallelism",
    "Use proper synchronization primitives",
]