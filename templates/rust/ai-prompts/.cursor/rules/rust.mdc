---
description: Rust development rules with modern tooling
globs: ["*.rs", "Cargo.toml", "Cargo.lock"]
alwaysApply: true
---

# Rust Development Guidelines

## Core Requirements

Use Rust 2021 edition exclusively with modern syntax and idioms. Use cargo fmt for all code formatting and cargo clippy with zero warnings policy. Use latest stable Rust features and patterns.

## Code Style

- Use snake_case for variables and functions
- Use PascalCase for types and traits
- Use SCREAMING_SNAKE_CASE for constants
- Use descriptive variable names and avoid abbreviations
- Use modern control flow: if let chains, let-else patterns, match expressions

## Error Handling

Use thiserror for library error types with structured error handling. Use anyhow for application error handling and error propagation. Use Result<T, E> for error handling, avoid unwrap() in production code. Use proper error propagation with ? operator.

## Data Types and Collections

- Use String for owned strings, &str for borrowed strings
- Use Vec<T> for dynamic collections instead of arrays
- Use HashMap and BTreeMap for key-value storage
- Use PathBuf for owned paths, &Path for borrowed paths
- Use generic types and traits for code reuse and flexibility
- Use #[derive(Debug, Clone, PartialEq)] for common traits

## Essential Libraries

- **serde**: For serialization with derive macros
- **tracing**: For structured logging instead of println! in production code
- **clap**: With derive API for command-line argument parsing
- **tokio**: For async runtime and I/O operations
- **anyhow**: For application error handling
- **thiserror**: For library error types

## Project Structure

Use workspace structure for multi-crate projects. Use modules for code organization and encapsulation. Use pub(crate) for internal APIs that need cross-module access. Use feature flags for optional functionality.

## Async Programming

Use async/await patterns for I/O operations with tokio runtime. Use async traits for async behavior. Use proper async error handling patterns. Use structured concurrency patterns.

## Testing

Use #[cfg(test)] modules for unit tests. Use assert! and assert_eq! for test assertions. Use integration tests in tests/ directory. Use criterion for benchmarking performance-critical code.

## Quality Assurance

Before committing code, always run:
1. `cargo fmt` - Format code
2. `cargo clippy --all-targets --all-features -- -D warnings` - Lint with zero warnings
3. `cargo test` - Run all tests
4. `cargo check --all-targets --all-features` - Verify compilation

## Documentation

Use documentation comments /// for public APIs. Write comprehensive examples in doc comments. Use type aliases for complex types to improve readability.

## Performance and Safety

Use iterators and functional programming patterns where appropriate. Use lifetime annotations only when necessary, prefer owned types. Avoid unsafe code unless absolutely necessary. Use smart pointers (Arc, Rc) for shared ownership.

## Memory Management

Use Box<T> for heap allocation when needed. Use Cow<T> for clone-on-write semantics. Use proper lifetime management. Avoid memory leaks and dangling pointers.