# Python Development Rules

## Language and Version
- Use Python 3.11+ exclusively with modern syntax and features
- Import `from __future__ import annotations` at the top of every Python file
- Use modern Python features: match statements, walrus operator, positional-only parameters

## Code Style and Formatting
- Use Ruff for all linting and formatting (never Black, isort, Flake8, or other tools)
- Use double quotes for strings consistently
- Use 4-space indentation (no tabs)
- Use f-strings for string formatting, never % formatting or .format()
- Use descriptive variable names, avoid abbreviations
- Use type hints for all function parameters and return values

## Project Structure
- Follow src/ directory structure for source code
- Use absolute imports from src module, not relative imports
- Place tests in tests/ directory with test_ prefix
- Use pyproject.toml for all configuration

## Libraries and Dependencies
- Use Pydantic Settings for configuration management with type-safe validation
- Use pathlib instead of os.path for file operations
- Use pytest for testing with fixtures and parametrized tests
- Use mypy for static type checking with strict configuration
- Use logging module for logging, not print statements
- Use enum.Enum for constants and enumerated values
- Use context managers (with statements) for resource management

## Data Structures
- Use dataclasses or Pydantic models for structured data, not plain dictionaries
- Use list comprehensions and generator expressions for data processing
- Use type-safe patterns and avoid `Any` type annotations
- Use modern collection types: dict, list, set (not Dict, List, Set from typing)

## Error Handling
- Use proper exception handling with specific exception types
- Use environment variables for configuration with pydantic-settings
- Follow patterns similar to anyhow for application error handling
- Create custom exception classes for library code

## Async Programming
- Use async/await patterns for I/O operations with modern Python async syntax
- Use asyncio for concurrent operations
- Use proper async context managers for resources

## Testing
- Use pytest with comprehensive test coverage
- Use fixtures for test setup and teardown
- Use parametrized tests for multiple test cases
- Write both unit tests and integration tests

## Code Quality
- Run `ruff format` and `ruff check --fix` before committing
- Run `mypy src/` for type checking
- Run `pytest` for testing
- Maintain zero linting warnings and type errors
- Write comprehensive docstrings for public functions and classes

## Documentation
- Write clear, concise docstrings with examples
- Use type hints as primary documentation for parameters
- Include usage examples in docstrings
- Document error conditions and exceptions

## Performance
- Use generators for large datasets
- Use appropriate data structures for the use case
- Profile code when performance is critical
- Cache expensive operations when appropriate

## Security
- Validate all user inputs
- Use secure random number generation
- Avoid eval() and exec() functions
- Follow secure coding practices for file operations